#
# Docker specific functions
#
################################################################
#
# Copyright (c) 2015 Oleg Girko
# Copyright (c) 2015 SUSE Linux Products GmbH
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################

vm_verify_options_docker() {
    VM_ROOT=
    VM_SWAP=
}

vm_startup_docker() {
    source $BUILD_ROOT/.build/build.data
    local name=$CONTAINER_NAME
    docker rm "$name" >/dev/null 2>&1 || true
    local docker_opts=
    local container_root="/mnt"
    local build_command=(chroot /mnt "$vm_init_script")
    local mounts=("--mount" "type=bind,source=$BUILD_ROOT,destination=/mnt")
    test -n "$VM_TYPE_PRIVILEGED" && docker_opts="--privileged --cap-add=SYS_ADMIN --cap-add=MKNOD"
    test -n "$RUN_SHELL" -o -n "$RUN_SHELL_AFTER_FAIL" && docker_opts="$docker_opts -it"
    local docker_image="busybox"
    if test -n "$VM_CONTAINER_IMAGE" ; then
        mkdir -p $BUILD_ROOT/home/abuild
        # create .build.packages link
        rm -rf $BUILD_ROOT/.build.packages
        ln -s home/abuild/rpmbuild $BUILD_ROOT/.build.packages
        docker_image="$VM_CONTAINER_IMAGE"
        container_root=
        mounts+=("--mount" "type=bind,source=$BUILD_ROOT/home/abuild,destination=/home/abuild")
        local build_command=(bash -c "
            # Create symlinks for /mnt hidden directories that include build script and data
            for item in /mnt/.[^.]*; do
                [ -d \"\$item\" ] && ln -sf \"\$item\" \"/\$(basename \"\$item\")\"
            done
            $vm_init_script
        ")
    fi
    mounts+=(
        "--mount" "type=bind,source=/proc,destination=$container_root/proc"
        "--mount" "type=bind,source=/dev/pts,destination=$container_root/dev/pts"
        "--mount" "type=bind,source=/dev/null,destination=$container_root/dev/null"
    )
    docker run \
        --rm --name "$name" --net=none $docker_opts \
        "${mounts[@]}" "$@" "$docker_image" "${build_command[@]}"
    BUILDSTATUS="$?"
    test "$BUILDSTATUS" != 255 || BUILDSTATUS=3
    cleanup_and_exit "$BUILDSTATUS"
}

vm_kill_docker() {
    source $BUILD_ROOT/.build/build.data
    local name=$CONTAINER_NAME
    docker stop -t 2 "$name" || true
}

vm_fixup_docker() {
    # we need this as marker for handling container specific code. Docker is setting it as well
    touch $BUILD_ROOT/.dockerenv
}

vm_attach_root_docker() {
    :
}

vm_attach_swap_docker() {
    :
}

vm_detach_root_docker() {
    :
}

vm_detach_swap_docker() {
    :
}

vm_cleanup_docker() {
    :
}

vm_sysrq_docker() {
    :
}

vm_wipe_docker() {
    local name="obsbuild.${BUILD_ROOT##*/}"
    docker rm "$name" >/dev/null 2>&1 || true
}
